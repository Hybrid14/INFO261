Objetivos del notebook
Las APIs Web son herramientas para hacer que la información y la funcionalidad de las aplicaciones sean accesibles a través de Internet. Los objetivos de este notebook consisten en:
Conocer qué es una API y cuándo se puede utilizar
Aprender a construir una API web que devuelva datos
Aprender algunos principios de buen diseño de API, aplicándolos a una API conectada a una base de datos
In [4]:
import platform
     
    print(platform.python_version())
3.6.6
Instalación de Python y Flask
Para este tutorial, necesitará Python 3.6 y la librería Flask (una librería Python que permite desarrollar aplicación web). Desde un terminal, instalar la librería Flash con el gestor de paquetes pip:
sudo python3.6 -m pip install flask
Una vez instalado flask, ejecutar el código siguiente para verificar que se instaló corectamente.
In [6]:
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "<h1>¡Hola Mundo!</h1> <p>Bienvenido en nuestra aplicación web básica en Python</p>"

if __name__ == "__main__":
    app.run(debug=False,port=1234)
 * Serving Flask app "__main__" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:1234/ (Press CTRL+C to quit)
¿Qué es una API?
Si ha escuchado el término API antes, es probable que se haya utilizado no para referirse a las API en general, sino a un tipo específico de API, la API web. Una API web permite que la información o funcionalidad sea manipulada por otros programas a través de Internet. Por ejemplo, con la API web de Twitter, puedes escribir un programa en un lenguaje como Python o Javascript que puede realizar tareas como favorecer tweets o recopilar metadatos de tweets.
En la programación en general, el término API, abreviatura de Application Programming Interface (Interfaz de programación de aplicaciones), se refiere a una parte de un programa diseñado para ser utilizado o manipulado por otro programa, a diferencia de una interfaz diseñada para ser utilizada o manipulada por un ser humano. Los programas a menudo necesitan comunicarse entre sí o con el sistema operativo subyacente, y las API son una forma de hacerlo. En este tutorial, sin embargo, utilizaremos el término API para referirnos específicamente a las APIs web.
Cuándo crear una API
En general, considere crear una API si:
Su conjunto de datos es grande, lo que hace que la descarga sea difícil de manejar o requiera muchos recursos.
Sus usuarios necesitarán acceder a sus datos en tiempo real, por ejemplo para mostrarlos en otro sitio web o como parte de una aplicación.
Sus datos cambian o se actualizan con frecuencia.
Sus usuarios sólo necesitan acceder a una parte de los datos en un momento dado.
Los usuarios tendrán que realizar acciones distintas a la recuperación de datos, como contribuir, actualizar o eliminar datos.
Si tiene datos que desea compartir con el mundo, una API es una forma de ponerlos en manos de otros. Sin embargo, las API no siempre son la mejor manera de compartir datos con los usuarios. Si el tamaño de los datos que está proporcionando es relativamente pequeño, puede proporcionar un dump de datos en forma de archivo descargable JSON, XML, CSV o SQLite. Dependiendo de sus recursos, este enfoque puede ser viable hasta un tamaño de descarga de unos pocos gigabytes.
Recuerde que puede proporcionar tanto un dump de datos como una API, y los usuarios individuales pueden encontrar uno u otro que se adapte mejor a su caso de uso. La aplicación OpenLibrary, por ejemplo, proporciona tanto un dump de datos como una API, cada una de las cuales sirve para diferentes casos de uso para diferentes usuarios.
Terminología de la API
Al utilizar o crear APIs, encontrará estos términos con frecuencia:
HTTP (Hypertext Transfer Protocol) es un protocolo que implementa una serie de "métodos" que permite manipular recursos (datos o aplicaciones) de un servidor desde un computador cliente. Los dos más comunes son GET, que extrae datos de un servidor, y POST, que empuja nuevos datos a un servidor.
URL (Uniform Resource Locator) - Una dirección para un recurso en la web.
JSON (JavaScript Object Notation) es un formato de almacenamiento de datos basado en texto que está diseñado para ser fácil de leer tanto para humanos como para máquinas. JSON es generalmente el formato más común para devolver datos a través de una API, siendo XML el segundo más común.
REST (REpresentational State Transfer) es una filosofía que describe algunas de las mejores prácticas para la implementación de APIs. Las APIs diseñadas teniendo en cuenta algunos o todos estos principios se denominan REST APIs. Aunque la API descrita en esta lección utiliza algunos principios de REST, existe un gran desacuerdo en torno a este término. Por esta razón, no describo las APIs de ejemplo aquí como APIs de REST, sino como APIs web o HTTP.
Lo que los usuarios quieren en una API
La documentación es el punto de partida de un usuario cuando trabaja con una nueva API, y las URL bien diseñadas facilitan a los usuarios la búsqueda intuitiva de recursos. Dado que ayudan a los usuarios a acceder rápidamente a la información a través de su API, estos elementos (documentación y URL bien concebidas) son la condición sine qua non de una buena API. Discutiremos estos elementos en mayor profundidad más adelante en este tutorial.
A medida que utilice otras APIs en sus proyectos, desarrollará un sentido de lo que constituye una buena API desde la perspectiva de un usuario potencial. Del mismo modo que los lectores fuertes a menudo hacen escritores fuertes, el uso de APIs creadas por otros y la evaluación crítica de su implementación y documentación le ayudará a diseñar mejor sus propias APIs.
Implementación de nuestra API
Visión general
Esta sección le mostrará cómo construir un prototipo de API utilizando Python y la libreria de Flask. Nuestro API de ejemplo adoptará la forma de un archivo de lectura a distancia, un catálogo de libros que va más allá de la información bibliográfica estándar e incluye datos de interés para quienes trabajan en proyectos digitales. En este caso, además del título y la fecha de publicación, nuestra API también indicará la primera frase de cada libro. Estos datos deberían ser suficientes para permitirnos visualizar algunas preguntas potenciales de investigación sin abrumarnos mientras nos enfocamos en el diseño de nuestra API.
Comenzaremos usando Flask para crear una página de inicio para nuestro sitio. En este paso, aprenderemos los conceptos básicos de cómo funciona Flask y nos aseguraremos de que nuestro software esté configurado correctamente. Una vez que tengamos una pequeña aplicación Flask trabajando en forma de página de inicio, la iteraremos en este sitio, convirtiéndola en una API funcional.
Creación de una aplicación web básica con Flask
Flask es un framework web para Python, lo que significa que proporciona funcionalidad para construir aplicaciones web, incluyendo la gestión de peticiones HTTP y plantillas de renderizado. En esta sección, crearemos una aplicación básica de Flask. En secciones posteriores, añadiremos a esta aplicación para crear nuestra API. No te preocupes si no entiendes cada línea de código individual todavía, las explicaciones se darán una vez que tengas esta versión inicial de la aplicación funcionando.
Primero, cree una nueva carpeta api en su carpeta INFO261 que servirá como una carpeta de proyecto. Este tutorial asumirá que los archivos relacionados con este notebook se almacenarán en una carpeta llamada api.
Cuándo ejecutaron la primera celda de código de este notebook, deben tener un output similar a  * Running on http://127.0.0.1:1234/ (Press CTRL+C to quit)
También puede ver algunas líneas relacionadas con el debugging. Este mensaje significa que Flask está ejecutando su aplicación localmente (en su ordenador) en esa dirección. Siga el enlace anterior, http://127.0.0.1:1234/, utilizando su navegador web para ver la aplicación en ejecución. ¡Felicitaciones, has creado una aplicación web que funciona!
Qué hace Flask
Ahora que tenemos una página de inicio para nuestra aplicación, hablemos de cómo funciona Flask y qué está haciendo el código anterior.
Flask asigna las peticiones HTTP a las funciones de Python. En este caso, hemos asignado una ruta URL ('/') a una función, home. Cuando nos conectamos al servidor Flask en http://127.0.0.1:1234/, Flask comprueba si hay una coincidencia entre la ruta proporcionada y una función definida. Puesto que /, o no se ha asignado ninguna ruta adicional, a la función de inicio, Flask ejecuta el código en la función y muestra el resultado devuelto en el navegador. En este caso, el resultado devuelto es un marcado HTML para una página de inicio que da la bienvenida a los visitantes al sitio que alberga nuestra futura API.
El proceso de asignar URLs a funciones se llama enrutamiento (routing).
In [2]:
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "<h1>¡Hola Mundo!</h1> <p>Bienvenido en nuestra aplicación web básica en Python</p>"

if __name__ == "__main__":
    app.run(debug=False,port=1234)
 * Serving Flask app "__main__" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:1234/ (Press CTRL+C to quit)
<code>@app.route('/', methods=['GET'])</code>: es la parte del programa que permite a Flask saber que esta función, home, debe ser asignada a la ruta /. La lista de métodos (methods=['GET']) es un argumento de palabra clave que permite a Flask saber qué tipo de peticiones HTTP están permitidas. Sólo usaremos peticiones GET en este tutorial, pero muchas aplicaciones web necesitan usar tanto peticiones GET (para enviar datos desde la aplicación al usuario) como peticiones POST (para recibir datos de un usuario).
Creación de la API
Ahora que tenemos una aplicación Flask en ejecución y sabemos un poco sobre lo que hace Flask, finalmente estamos listos para implementar una pequeña API con datos que definiremos directamente en nuestra aplicación.
Añadiremos nuestros datos como una lista de diccionarios Python. Diccionarios en pares de claves y valores del grupo Python, como este:
{ 'key': 'value', 'key': 'value' }
La clave identifica el tipo de información representada, como el título o el id. El valor son los datos reales. Por ejemplo, una guía telefónica corta podría tener este formato:
[ { 'name': 'Alexander Graham Bell', 'number': '1-333-444-5555' }, { 'name': 'Thomas A. Watson', 'number': '1-444-555-6666' } ]
La guía telefónica anterior es una lista de dos diccionarios. Cada diccionario es una entrada de la guía telefónica que consta de dos claves, nombre y número, cada una con un valor que proporciona la información real.
Añadamos algunos datos (entradas en tres novelas de ciencia ficción) como una lista de diccionarios. Cada diccionario contendrá el número de identificación, título, autor, primera frase y año de publicación de cada libro. Finalmente, añadiremos una nueva función: una ruta que permitirá al visitante acceder a nuestros datos.
NB: Terminar el proceso de la aplicación web anterior, antes de ejecutar la nueva versión
In [ ]:
import flask
from flask import request, jsonify

app = flask.Flask(__name__)

# Create some test data for our catalog in the form of a list of dictionaries.
books = [
    {'id': 0,
     'title': 'A Fire Upon the Deep',
     'author': 'Vernor Vinge',
     'first_sentence': 'The coldsleep itself was dreamless.',
     'year_published': '1992'},
    {'id': 1,
     'title': 'The Ones Who Walk Away From Omelas',
     'author': 'Ursula K. Le Guin',
     'first_sentence': 'With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.',
     'published': '1973'},
    {'id': 2,
     'title': 'Dhalgren',
     'author': 'Samuel R. Delany',
     'first_sentence': 'to wound the autumnal city.',
     'published': '1975'}
]


@app.route('/', methods=['GET'])
def home():
    return "<h1>¡Hola Mundo!</h1> <p>Bienvenido en nuestra aplicación web básica en Python</p>"

# A route to return all of the available entries in our catalog.
@app.route('/api/v1/resources/books/all', methods=['GET'])
def api_all():
    return jsonify(books)

app.run(debug=False,port=1234)
Una vez que el servidor esté funcionando, visite nuestra URL de la ruta para ver los datos en el catálogo:
http://127.0.0.1:1234/api/v1/resources/books/all
Debería ver la salida JSON de las tres entradas en nuestro catálogo de pruebas. Flask nos proporciona una función jsonify que nos permite convertir listas y diccionarios al formato JSON. En la ruta que creamos, nuestras entradas de libro se convierten de una lista de diccionarios Python a JSON antes de ser devueltas a un usuario.
En este punto, ha creado una API que funciona, aunque limitada. En la siguiente sección, permitiremos a los usuarios encontrar libros a través de datos más específicos, como el ID de una entrada.
Encontrar recursos específicos
En este momento, los usuarios sólo pueden ver toda nuestra base de datos, no pueden filtrar ni encontrar recursos específicos. Si bien esto no es un problema con nuestro catálogo de pruebas, rápidamente se volverá menos útil a medida que agreguemos datos. En esta sección, añadiremos una función que permite a los usuarios filtrar los resultados devueltos mediante una petición más específica.
A continuación se muestra el código de nuestra nueva aplicación con capacidad de filtrado. Como antes, examinaremos el código más cuidadosamente una vez que lo tenga en funcionamiento.
In [1]:
import flask
from flask import request, jsonify

app = flask.Flask(__name__)

# Create some test data for our catalog in the form of a list of dictionaries.
books = [
    {'id': 0,
     'title': 'A Fire Upon the Deep',
     'author': 'Vernor Vinge',
     'first_sentence': 'The coldsleep itself was dreamless.',
     'year_published': '1992'},
    {'id': 1,
     'title': 'The Ones Who Walk Away From Omelas',
     'author': 'Ursula K. Le Guin',
     'first_sentence': 'With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.',
     'published': '1973'},
    {'id': 2,
     'title': 'Dhalgren',
     'author': 'Samuel R. Delany',
     'first_sentence': 'to wound the autumnal city.',
     'published': '1975'}
]


@app.route('/', methods=['GET'])
def home():
    return '''<h1>Nuestra API: Open Books</h1>
<p>Un prototipo de API para acceder a libros de ciencia ficción.</p>'''


@app.route('/api/v1/resources/books/all', methods=['GET'])
def api_all():
    return jsonify(books)


@app.route('/api/v1/resources/books', methods=['GET'])
def api_id():
    # Check if an ID was provided as part of the URL.
    # If ID is provided, assign it to a variable.
    # If no ID is provided, display an error in the browser.
    if 'id' in request.args:
        id = int(request.args['id'])
    else:
        return "Error: No id field provided. Please specify an id."

    # Create an empty list for our results
    results = []

    # Loop through the data and match results that fit the requested ID.
    # IDs are unique, but other fields might return many results
    for book in books:
        if book['id'] == id:
            results.append(book)

    # Use the jsonify function from Flask to convert our list of
    # Python dictionaries to the JSON format.
    return jsonify(results)


app.run(debug=False,port=1234)
 * Serving Flask app "__main__" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:1234/ (Press CTRL+C to quit)
127.0.0.1 - - [02/Nov/2018 12:54:30] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [02/Nov/2018 12:54:30] "GET /favicon.ico HTTP/1.1" 404 -
127.0.0.1 - - [02/Nov/2018 12:54:30] "GET /favicon.ico HTTP/1.1" 404 -
127.0.0.1 - - [02/Nov/2018 12:54:32] "GET /api/v1/resources/books?id=0 HTTP/1.1" 200 -
Visite las siguientes URLs para probar la nueva capacidad de su API:
http://127.0.0.1:1234/api/v1/resources/books?id=0
http://127.0.0.1:1234/api/v1/resources/books?id=1
http://127.0.0.1:1234/api/v1/resources/books?id=2
http://127.0.0.1:1234/api/v1/resources/books?id=3
Cada uno de ellos debe devolver una entrada diferente, excepto el último, que debe devolver una lista vacía: [], ya que no hay ningún libro para el cual el valor de id sea 3. (El conteo en la programación típicamente comienza en 0, así que id=3 sería una petición para un cuarto ítem inexistente.
Examine la URL proporcionada para una identificación y seleccione los libros que coincidan con esa identificación. La identificación debe ser proporcionada de esta manera: ?id=0. Los datos pasados a través de URLs como ésta (después del ?) se llaman parámetros de consulta. Son una característica de HTTP utilizada para filtrar tipos específicos de datos.
Principios de diseño de API
Hasta ahora, hemos creado una API de trabajo con datos de prueba que hemos proporcionado directamente en nuestra aplicación. Nuestra próxima versión de nuestra API extraerá datos de una base de datos antes de proporcionárselos a un usuario. También tomará parámetros de consulta adicionales, permitiendo a los usuarios filtrar por campos que no sean ID.
Antes de incluir más funcionalidad en nuestra aplicación, reflexionemos sobre algunas de las decisiones de diseño de API que hemos tomado hasta ahora. Dos aspectos de una buena API son la usabilidad y la mantenibilidad, y a medida que incorporemos más funcionalidad a nuestra API, tendremos en cuenta muchas de las siguientes consideraciones.
Diseño de Solicitudes
La filosofía de diseño predominante de las API modernas se llama REST. Para nuestros propósitos, lo más importante de REST es que se basa en los cuatro métodos definidos por el protocolo HTTP: POST, GET, PUT y DELETE. Estas corresponden a las cuatro acciones tradicionales realizadas sobre los datos de una base de datos: CREAR, LEER, ACTUALIZAR y BORRAR. En este tutorial, sólo nos ocuparemos de las peticiones GET, que corresponden a la lectura de una base de datos.
Debido a que las peticiones HTTP son tan esenciales para el uso de una API de REST, muchos principios de diseño giran en torno a cómo se deben formatear las peticiones. Ya hemos creado una petición HTTP, que devuelve todos los libros proporcionados en nuestros datos de muestra. Para entender las consideraciones que entran en el formateo de esta solicitud, primero consideremos un ejemplo débil o mal diseñado de un punto final de la API:
 http://api.example.com/getbook/10 
El formato de esta solicitud tiene varios problemas. El primero es semántico - en una API REST, nuestros verbos son típicamente GET, POST, PUT, o DELETE, y están determinados por el método de petición en lugar de por la URL de petición. Esto significa que la palabra "get" no debería aparecer en nuestra petición, ya que "get" está implícito en el hecho de que estamos usando un método HTTP GET. Además, las colecciones de recursos, como los libros o los usuarios, deben indicarse con sustantivos plurales. Esto deja claro cuando una API se refiere a una colección (libros) o una entrada (libro). Incorporando estos principios, nuestra API se vería así:
http://api.example.com/books/10
La solicitud anterior utiliza parte de la ruta (/10) para proporcionar el ID. Aunque este no es un enfoque poco común, es un algo inflexible: con las URL construidas de esta manera, por lo general sólo se puede filtrar por un campo a la vez. Los parámetros de consulta permiten filtrar por múltiples campos de base de datos y tienen más sentido cuando se proporcionan datos "opcionales", como un formato de salida:
http://api.example.com/books?author=Ursula+K.+LeGuin&published=1969&output=xml
Al diseñar cómo deben estructurarse las solicitudes a su API, también tiene sentido planificar las adiciones futuras. Incluso si la versión actual de su API sólo ofrece información sobre un tipo de recursos (por ejemplo, libros), tiene sentido planificar como si pudiera añadir otros recursos o funciones que no sean recursos a su API en el futuro:
http://api.example.com/resources/books?id=10
Agregar un segmento adicional en la ruta, como "recursos" o "entradas", le da la opción de permitir que los usuarios busquen en todos los recursos disponibles, lo que le facilita las solicitudes de soporte posteriores como éstas:
https://api.example.com/v1/resources/images?id=10
https://api.example.com/v1/resources/all
Otra forma de planificar el futuro de su API es añadir un número de versión a la ruta. Esto significa que, en caso de que tenga que rediseñar su API, puede seguir soportando la versión antigua de la API con el número de versión antiguo mientras libera, por ejemplo, una segunda versión (v2) con funcionalidad mejorada o diferente. De esta manera, las aplicaciones y los scripts creados utilizando la versión antigua de su API no dejarán de funcionar después de la actualización.
Después de incorporar estas mejoras de diseño, una solicitud a nuestra API podría verse así:
https://api.example.com/v1/resources/books?id=10
Documentación y ejemplos
Sin documentación, incluso la API mejor diseñada será inutilizable. Su API debe tener documentación que describa los recursos o la funcionalidad disponibles a través de su API que también proporcione ejemplos concretos de URL de solicitud o código para su API. Debe tener una sección para cada recurso que describa qué campos, como el id o el título, acepta. Cada sección debe tener un ejemplo en forma de una solicitud HTTP de ejemplo o un bloque de código.
Para obtener inspiración sobre cómo abordar la documentación de la API, consulte por ejemplo las API siguientes:
New York Public Library Digital Collections API
World Bank API
las APIS del New York Times
Europeana Pro API
Conexión de nuestra API a una base de datos
En el código siguiente, mostramos un ejemplo de cómo acceder a datos de la base de datos Sakila (NB: en teoría esta base de datos existe en su SGBD MySQL local) a través una API web.
In [6]:
import flask
import json
from flask import request, jsonify
import mysql.connector

# Creación de una nueva aplicación web
app = flask.Flask(__name__)

# Conexión al SGBD
  ## reemplazar 'root' por el password del usuario administrador de MySQL
conn = mysql.connector.connect(user="root",host="localhost",password="bonjovi95")
cursor = conn.cursor()
cursor.execute("USE sakila")

# Definición de las rutas

@app.route('/', methods=['GET'])
def home():
    return '''<h1>API Sakila</h1>
<p>Un prototipo de API para la base de datos Sakila.</p>'''

@app.errorhandler(404)
def page_not_found(e):
    return "<h1>404</h1><p>The resource could not be found.</p>", 404

@app.route('/api_sakila/v1/resources/films/all', methods=['GET'])
def api_all():
    ## Consultar MySQL para obtener datos sobre las peliculas
    result=cursor.execute('SELECT film_id,title,description,release_year,language_id FROM film;')
    all_films =cursor.fetchall()
    ## Conservar el nombre de los atributos
    row_headers=[x[0] for x in cursor.description]
    ## Transformar resultados en datos JSON
    json_data=[]
    for result in all_films:
        json_data.append(dict(zip(row_headers,result)))
    return jsonify(json_data)

@app.route('/api_sakila/v1/resources/films', methods=['GET'])
def api_filter():
    ## Definir parametros posibles
    query_parameters = request.args

    release_year = query_parameters.get('release_year')
    language_id = query_parameters.get('language_id')
    
    ##Construir la consulta SQL según parametros
    query = "SELECT film_id,title,description,release_year,language_id FROM film WHERE"
    to_filter = []

    if release_year:
        query += ' release_year=%s AND'
        to_filter.append(release_year)
    if language_id:
        query+= ' language_id=%s AND'
        to_filter.append(language_id)
    if not (release_year or language_id):
        return page_not_found(404)

    query = query[:-4] + ';'
    
    print(query)
    print(to_filter)
    
    ## Consultar
    results=cursor.execute(query,to_filter)
    some_films =cursor.fetchall()
    ## Conservar el nombre de los atributos
    row_headers=[x[0] for x in cursor.description]
    ## Transformar resultados en datos JSON
    json_data=[]
    for result in some_films:
        json_data.append(dict(zip(row_headers,result)))
    return jsonify(json_data)

app.run(debug=False,port=1234)
 * Serving Flask app "__main__" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:1234/ (Press CTRL+C to quit)
127.0.0.1 - - [02/Nov/2018 13:17:59] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [02/Nov/2018 13:17:59] "GET /favicon.ico HTTP/1.1" 404 -
Probar los distintos puntos de acceso de su API desde su navegador
Recursos
Tutorial completo para desarrollar aplicaciones web con Flask: The Flask Mega Tutorial
Algunas API abiertas bacanes:
Connecting Repositories (CORE) - A collection of open access articles from various sources hosted by the Open University.
History Data Service (HDS) - A collection of data from a wide variety of historical sources.
Europeana
Open Library
Digging into Data API List
Ejercicio
1) Diseñar una API a partir de un caso de uso que ustedes definen (por ejemplo, puede ser el caso de uso que han definido la semana pasada sobre el tema de SmartCity)
2) Implementar su API
3) ¿Cómo podrían desplegar su API más allá de su computador local?
4) ¿Observan algunas limitaciones al momento de crear una API web basada en MySQL?
5) ¿Qué es el movimiento de Open Data? ¿En qué sentido podría aportar a la ciudad de Valdivia?
In [ ]:
#Ejercicio 1-2 
#basado en la base de Datos GranSlam implementada en clases.



import flask
import json
from flask import request, jsonify
import mysql.connector

# Creación de una nueva aplicación web
app = flask.Flask(__name__)

# Conexión al SGBD
conn = mysql.connector.connect(user="root",host="localhost",password="bonjovi95")
cursor = conn.cursor()
cursor.execute("USE GrandSlam")

# Definición de las rutas
@app.route('/', methods=['GET'])
def home():
    return '''<h1>API GrandSlam</h1>
<p>API para la base de datos GrandSlam.</p>'''

@app.errorhandler(404)
def page_not_found(e):
    return "<h1>404</h1><p>The resource could not be found.</p>", 404

@app.route('/api_GrandSlam/v1/resources/Jugador/all', methods=['GET'])
def api_all():
    ## Consultar MySQL para obtener datos sobre las entidades
    result=cursor.execute('SELECT id_jugador, nombre, genero, edad FROM Jugador;')
    all_Jugador =cursor.fetchall()
    ## Conservar el nombre de los atributos
    row_headers=[x[0] for x in cursor.description]
    ## Transformar resultados en datos JSON
    json_data=[]
    for result in all_Jugador:
        json_data.append(dict(zip(row_headers,result)))
    return jsonify(json_data)

@app.route('/api_GrandSlam/v1/resources/Jugador', methods=['GET'])
def api_filter():
    ## Definir parametros posibles
    query_parameters = request.args

    id_jugador = query_parameters.get('id_jugador')
    nombre = query_parameters.get('nombre')
    genero = query_parameters.get('genero')
    edad = query_parameters.get('edad')
    
    ##Construir la consulta SQL según parametros
    query = "SELECT id_jugador, nombre, genero, edad FROM Jugador WHERE"
    to_filter = []

    if id_jugador:
        query += ' id_jugador=%s AND'
        to_filter.append(id_jugador)
    if nombre:
        query+= ' nombre=%s AND'
        to_filter.append(nombre)
    if genero:
        query+= ' genero=%s AND'
        to_filter.append(genero)
    if edad:
        query+= ' edad=%s AND'
        to_filter.append(edad)
    if not (id_jugador or nombre or genero or edad):
        return page_not_found(404)

    query = query[:-4] + ';'
    
    print(query)
    print(to_filter)
    
    ## Consultar
    results=cursor.execute(query,to_filter)
    algun_Jugador =cursor.fetchall()
    ## Conservar el nombre de los atributos
    row_headers=[x[0] for x in cursor.description]
    ## Transformar resultados en datos JSON
    json_data=[]
    for result in algun_Jugador:
        json_data.append(dict(zip(row_headers,result)))
    return jsonify(json_data)

app.run(debug=False,port=1234)
 * Serving Flask app "__main__" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:1234/ (Press CTRL+C to quit)
127.0.0.1 - - [03/Nov/2018 19:04:13] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [03/Nov/2018 19:04:13] "GET /favicon.ico HTTP/1.1" 404 -
127.0.0.1 - - [03/Nov/2018 19:04:47] "GET /api_GrandSlam/v1/resources/Jugador HTTP/1.1" 404 -
127.0.0.1 - - [03/Nov/2018 19:05:05] "GET /api_GrandSlam/v1/resources/Jugador/all HTTP/1.1" 200 -
127.0.0.1 - - [03/Nov/2018 19:05:24] "GET /api_GrandSlam/v1/resources/Jugador?id_jugador=1 HTTP/1.1" 200 -
SELECT id_jugador, nombre, genero, edad FROM Jugador WHERE id_jugador=%s;
['1']
In [ ]:
#Ejercicio 3

Se puede desplegar la API más alla de la computadora local al hacer una modificación en el código, especificamente en la
instrucción app.run(debug=False,port=1234), la cuál cuenta con la opcion " host='' ", la cual nos permite ingresar una 
IP donde se alojaría nuestra API, en este caso, al no estar definido esto se utiliza la IP local 127.0.0.1.

Por ejemplo, al modificar esto y tener: 
    app.run(host='192.168.1.13', debug=False,port=1234)
tendríamos que se está alojando en la IP que corresponde al computador en el router, por lo que otras máquinas que estén
conectadas al router podrán tener acceso a la base de datos con la dirección 192.168.1.13:1234.
    
Para poder acceder desde cualquier parte, se necesitaria una IP pública.
In [ ]:
#Ejercicio 4

Una de las complicaciones que presenta mysql, a mi parecer, es la estructura en que se guarda la información, debido a que
la forma de acceder a datos especificos resulta muy complicada, cuando se necesitan datos con caracteristicas especificas 
a la hora de filtrarlos, ya que se deben definir muchos parametros en la instrucción SELECT.
Además si se quiere hacer una relación entre datos de distintas tablas, esto se complica aún más.
In [ ]:
#Ejercicio 5

El movimiento Open Data es un pensamiento que busca que ciertos tipos de datos estén disponibles de forma libre para todos,
sin patentes, derechos de autor, entre otros.

Al hacer una implementación intensiva en las aplicaciones que recolectan datos en la ciudad de Valdivia, se abriría una
enorme cantidad de posibilidades en cuanto a aplicaciones que trabajen con estos datos para organizar y controlar flujos
de actividades. Por ejemplo: Aplicaciones que permitan el conocimiento sobre uso de estacionamientos en la ciudad;
aplicaciones que permitan conocer la calidad de el aire en la ciudad en cualquier punto de esta; aplicaciones que ayuden
al control de la basura y su reciclaje; entre otras.

Todos estos ejemplos necesitan tener datos externos, y sería mucho más fácil si alguien más los obtuvo y solo se deben
trabajar e interpretar, además estas pueden generar aún más datos.
